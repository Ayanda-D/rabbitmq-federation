WARNING
=======

This is all very experimental. You have been warned.

You need branch bug23939 of the server!

Generic build instructions are at:
        http://www.rabbitmq.com/plugin-development.html


Limitations
===========

Significant limitation: rabbitmq-federation is not compatible with
clustering. *Do not deploy it in a cluster*. We intend to fix this
at some point.

Other limitations: you can't federate headers exchanges, there's no
status reporting, lots of (harmless) errors get written to the logs.


Purpose
=======

The high level goal is to transmit messages between brokers without
requiring clustering. This is useful for the following reasons:

1) Federated brokers may be in different administrative
   domains. Clustered brokers form a single administrative domain.

   a) Federated brokers may have different users and virtual hosts.
      Federated brokers only need to partially trust each other.

   b) Federated brokers may run different versions of RabbitMQ and
      Erlang.

2) Federated brokers only speak AMQP to each other, and the federation
   mechanism is designed to deal with intermittent connectivity.
   Federation is therefore much more WAN-friendly.

3) Brokers can contain federated and local-only components - you don't
   need to federate everything if you don't want to.

4) Ultimately, greater scalability should be possible.

For the time being, the plugin provides a federated exchange
type. Other features might appear in the future. In particular this
means that federation is primarily useful in pub/sub scenarios.


HOWTO
=====

A federated exchange has type 'x-federation'. However, this type does
not provide any routing logic. The routing logic is implemented by a
backing type, provided to the exchange as an argument.

Messages can be published to a federated exchange like any
other. However, a federated exchange will also receive messages from
one or more "upstream" exchanges, located on remote brokers.

(Well, you don't need to have upstream exchanges, and they don't need
to be remote. But then you don't get anything very useful.)

An upstream exchange can be a regular exchange or a federation
exchange. It is expected that upstream and downstream exchanges will
have the same type (or backing type). Mixing types will lead to
strange routing behaviour.

Inter-broker communication is implemented using AMQP (optionally
secured with SSL). The federation plugin will ensure that only
messages that will be received from the downstream exchange are sent
over the wire.

A typical use would be to have the same "logical" exchange distributed
over many brokers. This would be achieved by having the exchange
declared as a federated exchange in each broker, with upstreams
corresponding to all the other brokers.

Other topologies are possible; however one notable current limitation
is that the federation plugin will not forward the same message more
than once. Therefore your inter-broker topology needs to be fully
connected. We intend to remove this limitation in future.

Federated exchanges can be set up statically via broker configuration,
or declared dynamically over AMQP.


Static Configuration
====================

A reasonably verbose static configuration might look like:

  {rabbit_federation,
   [ {exchanges, [[{exchange,     "my-exchange"},
                   {virtual_host, "/"},
                   {type,         "topic"},
                   {durable,      true},
                   {auto_delete,  false},
                   {internal,     false},
                   {upstreams,    [[{host,     "upstream-server"},
                                    {protocol, "amqps"}]]}]
                 ]},
     {brokers, [[{host,            "upstream-server"},
                 {protocol,        "amqps"},
                 {username,        "myusername"},
                 {password,        "secret"},
                 {prefetch_count,  1000},
                 {reconnect_delay, 5},
                 {heartbeat,       10},
                 {queue_expires,   30}]
               ]},
     {ssl_options,
      [{cacertfile,           "/path/to/cacert.pem"},
       {certfile,             "/path/to/cert.pem"},
       {keyfile,              "/path/to/key.pem"},
       {verify,               verify_peer},
       {fail_if_no_peer_cert, true}
     ]},
     {local_username, "myusername"},
     {local_password, "secret"}
   ]
  }

Within the list of exchanges, the upstreams parameter is a list of
remote exchanges whose messages should be federated to the local
exchange. You can specify host, port, protocol, virtual_host and
exchange here. Only host is mandatory; if protocol is omitted the
protocol is taken as "amqp", and if virtual_host or exchange are
omitted the default is the same as the downstream exchange.

Most of the rest of the list of exchanges looks like a set of
exchange.declares, but note that the type parameter must match the
type of the upstream exchanges for routing to work at all sensibly.

The brokers list provides information on how to connect to brokers
mentioned in the upstreams list. It can match on the following properties:

host
  - hostname to connect to

protocol
  - "amqp" or "amqps"

virtual_host
  - if present, distinguish between different sets of broker
    properties for different virtual hosts on the same broker

And can contain the following options:

username
  - user to connect as. Default is "guest".

password
  - password to use. Default is "guest".

mechanism
  - SASL mechanism to use. Either default (to use by default PLAIN or
    AMQPLAIN), or 'EXTERNAL' to use SASL EXTERNAL authentication
    (e.g. rabbitmq-auth-mechanism-ssl)

prefetch_count
  - limit on the maximum number of unacknowledged messages in flight
    per link. Default is none.

reconnect_delay
  - time in seconds to wait to reconnect to the broker after being
    disconnected. Default is 1.

heartbeat
  - AMQP heartbeat interval (in seconds) on the connection, or none. Default
    is none.

queue_expires
  - How long to keep the upstream queue around (and collecting
    messages) when disconnected, in seconds. Default is 1800 (half an hour).

The ssl_options parameter specifies how to make client SSL
connections. See the Erlang client documentation for more details.

The local_username and local_password parameters specify how to
connect to the local broker. The default for both is "guest".

Declaring Federation Exchanges Over AMQP
========================================

This is a less common case, but in case you want to do this:

 * Declare the downstream exchange with type "x-federation".

 * Give it arguments "type" and "upstreams". "type" should refer to
   its backing type; the type of the upstream exchanges. "upstreams"
   should be an array of tables. Each table must have a "host" fields,
   and may also have "protocol", "port", "virtual_host" and "exchange"
   fields. TODO example.

 * Connection information and SSL parameters will still be taken from the
   static configuration.

Example using the Java API:

Map<String, Object> upstream = new HashMap<String, Object>();
upstream.put("host", "remote-server");
upstream.put("exchange", "upstream-exchange");

ArrayList<Map<String, Object>> upstreams = new ArrayList<Map<String, Object>>();
upstreams.add(upstream);

Map<String, Object> args = new HashMap<String, Object>();
args.put("type", "topic");
args.put("upstreams", upstreams);

Channel ch = ...;
ch.exchangeDeclare("my-federated-exchange", "x-federation", true, false, args);
