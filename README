WARNING
=======

This is all very experimental. You have been warned.

You need branch bug22953 of rabbitmq-server.

Generic build instructions are at:
        http://www.rabbitmq.com/plugin-development.html

Significant limitation: rabbitmq-federation is not compatible with
clustering. *Do not deploy it in a cluster*. Obviously we'll fix this
at some point.


Purpose
=======

The high level goal is to transmit messages between brokers without
requiring clustering. This is useful for the following reasons:

1) Federated brokers may be in different administrative
   domains. Clustered brokers form a single administrative domain.

   a) Federated brokers may have different users and vhosts. Federated
      brokers only need to partially trust each other.

   b) Federated brokers may run different versions of RabbitMQ and
      Erlang.

2) Federated brokers only speak AMQP to each other, and the federation
   mechanism is designed to deal with intermittent connectivity.
   Federation is therefore much more WAN-friendly.

3) Brokers can contain federated and local-only components - you don't
   need to federate everything if you don't want to.

4) Ultimately, greater scalability should be possible.

For the time being, the plugin provides a federated exchange
type. Other features might appear in the future. In particular this
means that federation is primarily useful in pub/sub scenarios.


HOWTO
=====

A federated exchange has type 'x-federation'. However, this type does
not provide any routing logic. The routing logic is implemented by a
backing type, provided to the exchange as an argument. Messages can
therefore be published to a federated exchange like any
other. However, a federated exchange will also receive messages from
one or more "upstream" exchanges, located on remote brokers.

(Well, you don't need to have upstream exchanges, and they don't need
to be remote. But then you don't get anything very useful.)

Inter-broker communication is implemented entirely using AMQP
(optionally secured with SSL). The federation plugin will ensure that
only messages that will be received from the downstream exchange are
sent over the wire.

A typical use would be to have the same "logical" exchange distributed
over many brokers. This would be achieved by having the exchange
declared as a federated exchange in each broker, with upstreams
corresponding to all the other brokers.

Other topologies are possible; however one notable current limitation
is that the federation plugin will not forward the same message more
than once. Therefore your inter-broker topology needs to be fully
connected. We intend to remove this limitation in future.

Federated exchanges can be set up statically via broker configuration,
or declared dynamically over AMQP.


Static Configuration
====================

A reasonably verbose static configuration might look like:

  {rabbit_federation,
   [ {exchanges, [[{exchange,    "my-exchange"},
                   {vhost,       "/"},
                   {type,        "topic"},
                   {durable,     true},
                   {auto_delete, false},
                   {internal,    false},
                   {upstreams,   ["amqps://upstream-server/%2f/my-exchange"]}]
                 ]},
     {brokers, [[{host,            "upstream-server"},
                 {scheme,          "amqps"},
                 {username,        "myusername"},
                 {password,        "secret"},
                 {prefetch_count,  10},
                 {reconnect_delay, 5},
                 {heartbeat,       10},
                 {queue_expires,   30}]
               ]},
     {ssl_options,
      [{cacertfile,           "/path/to/cacert.pem"},
       {certfile,             "/path/to/cert.pem"},
       {keyfile,              "/path/to/key.pem"},
       {verify,               verify_peer},
       {fail_if_no_peer_cert, true}
     ]},
     {local_username, "myusername"},
     {local_password, "secret"}
   ]
  }

The upstreams parameter is a list of remote exchanges whose messages
should be federated to the local exchange.

Most of the rest looks like an exchange.declare, but note that *the
type parameter must match the type of the upstream exchanges for
routing to work at all sensibly*.

The brokers list provides information on how to connect to brokers
mentioned in the upstreams list. It can match on the following properties:

host
  - hostname to connect to

scheme
  - "amqp" or "amqps"

vhost
  - if present, distinguish between different sets of broker
    properties for different virtual hosts on the same broker

And can contain the following options:

username
  - user to connect as. Default is "guest".

password
  - password to use. Default is "guest".

mechanism
  - SASL mechanism to use. Either default (to use by default PLAIN or
    AMQPLAIN), or 'EXTERNAL' to use SASL EXTERNAL authentication
    (e.g. rabbitmq-auth-mechanism-ssl)

prefetch_count
  - maximum number of unacknowledged messages in flight per link. Default
    is 100.

reconnect_delay
  - time in seconds to wait to reconnect to the broker after being
    disconnected. Default is 1.

heartbeat
  - AMQP heartbeat interval (in seconds) on the connection, or none. Default
    is none.

queue_expires
  - How long to keep the upstream queue around (and collecting
    messages) when disconnected, in seconds. Default is 1800 (half an hour).

The ssl_options parameter specifies how to make client SSL
connections. See the Erlang client documentation for more details.

The local_username and local_password parameters specify how to
connect to the local broker. Both are mandatory.

Declaring Over AMQP
===================

This is less common, but in case you want to do this:

 * Declare the downstream with type "x-federation".

 * Give it arguments "type" and "upstreams". "type" should refer to
   its backing type; the type of the upstream exchanges. "upstreams"
   should be an array of URIs.

 * Connection information and SSL parameters will still be taken from the
   static configuration.


Limitations
===========

See TODO for a bunch of stuff that's not yet done.
